# Создание событий

Именно здесь мы начнем творить волшебство для нашего пользовательского интерфейса. Посмотрите снова на модуль **app.rs**, потому что сейчас мы добавим метод **App::connect_events()**.

## ConnectedApp

Однако, прежде чем мы начнём, заранее создадим обёртку **ConnectedApp**, реализующую метод **then_execute()**, который мы видели ранее.
Цель будет преобразовывать **App** в **ConnectedApp** после того, как в
 **App** будет вызван метод **App::connect_events()**.

```rust
/// Обёртка `App`, обеспечивывающая запуск программы.
pub struct ConnectedApp(App);

impl ConnectedApp {
    /// Покажем окно и запустим главный цикл событий GTK.
    pub fn then_execute(self) {
        self.0.window.show_all();
        gtk::main();
    }
}
```

## connect_events()

Продолжим и наконец-то добавим метод **App::connect_events()** в блок **impl**
с типом **App**, в котором объявим право на владение **App** и вернём **ConnectedApp** в конец. 

```rust
/// Создадим внешнее состояние и сравним всю функциональность UI.
impl App {
    pub fn new() -> App { ... }

    pub fn connect_events(self) -> ConnectedApp {
        // Внешнее состояние для обмена событиями.
        let current_file = Arc::new(RwLock::new(None));

        // Соединим все события, с которыми будет взаимодействовать UI.
        self.editor_changed(
            current_file.clone(),
            &self.header.save.clone()
        );

        // Завернём `App` внутрь `ConnectedApp`, чтобы
        // выполнить программу.
        ConnectedApp(self)
    }
}
```

С помощью типа **ActiveMetadata**, который мы создали ранее, создадим переменную
**RwLock'd** **current_file**, которая содержит **Option\<ActiveMetadata\>**.
По умолчанию, установленное значение равно **None**, т.к. сначала не будет доступного файла для отслеживания.

Первым событием будет изменение исходного буфера, который мы реализуем в методе **App::editor_changed()**. Этот метод будет принимать ссылку на **RwLock'd** **current_file**,
а также ссылку на кнопку **Save**. Значение проходит через кнопку сохранения и изменяется в зависимости от *чувствительности* содержимого буфера.

> Если кнопка неактивна, то вы не можете нажать на неё.
