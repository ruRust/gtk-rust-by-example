# Работа с внешним состоянием
Данная часть рассматривает модуль **state.rs**, который будет содержать в себе
типы, используемые для работы с не-GTK внешним состоянием. Это будет очень
просто, потому что Markdown-редактор не хранит большой объем данных во внешнем
хранилище.
## Что нам нужно?
Имеются два ключевых компонента, которые должны нас заботить в течение времени
жизни программы
- путь к редактируемому файлу
- хеш-сумма содержимого файла для сравнения текущего содержимого редактора с
содержимым файла для того чтобы знать, когда активировать/деактивировать
кнопку **Save**.
## ActiveMetadata
Так появилась структура **ActiveMetadata**. Она содержит **PathBuf**,
используемый для хранения пути к редактируемому файлу, и 64-байтный
хеш, который будет сгенерирован функцией **keccak512()** из пакета
[tiny-keccak](https://docs.rs/tiny-keccak/1.4.0/tiny_keccak/fn.keccak512.html)
```rust
use std::path::{Path, PathBuf};
use tiny_keccak::keccak512;

pub struct ActiveMetadata {
    path: PathBuf,
    sum:  [u8; 64],
}
```
Реализация методов для этого типа будет простой. Мы должны создать:
- новый экземпляр метаданных
- функцию для получения ссылки на путь к файлу
- функцию для проверки того, что хеш-сумма содержимого в редакторе такая же,
как и хранимая в структуре, функцию для обновления значения хеш-суммы при
сохранении файла
```rust
impl ActiveMetadata {
    pub fn new(path: PathBuf, data: &[u8]) -> ActiveMetadata {
        ActiveMetadata { path, sum: keccak512(data) }
    }

    pub fn get_path<'a>(&'a self) -> &'a Path { &self.path }

    pub fn get_dir(&self) -> Option<PathBuf> { self.path.parent().map(|p| p.to_path_buf()) }

    pub fn is_same_as(&self, data: &[u8]) -> bool { &keccak512(data)[..] == &self.sum[..] }

    pub fn set_sum(&mut self, data: &[u8]) { self.sum = keccak512(data); }
}
```