# Настройка модулей
![head_pic](https://mmstick.github.io/gtkrs-tutorials/images/ch04_mod_diagram.png)

В данной главе мы начнем использовать модули, чтобы разделить код на отдельные
части. Следуя приведенной выше диаграмме мы отделим GTK-специфичную часть кода
от остального кода.

- модуль **ui** будет содержать весь код, относящийся к построению и выполнению
GTK-программы.
- модуль **preview** генерирует HTML из предоставленного Markdown.
- модуль **state** содержит типы, которые используются для работы с внешним
состоянием.

## Создание модулей
![creating_modules](https://mmstick.github.io/gtkrs-tutorials/images/ch04_mod_structure.png)

Модули **preview** и **state** относительно простые, они могут быть
представлены двумя Rust-файлами: **preview.rs** и **state.rs**. Модуль **ui**
будет гораздо более сложным, содержа в себе подмодули. У нас будет директория
**ui** где будет точка входа в модуль в виде файла **mod.rs** внутри
директории.

## Файл **main.rs**
Как только мы настроим основные модули, мы свяжем всё воедино и соединим с
главной точкой входа в программу - **main.rs**. Первоначальная версия будет
выглядеть так:
```rust
extern crate gdk;
extern crate gtk;
#[macro_use]
extern crate horrorshow;
extern crate pango;
extern crate pulldown_cmark;
extern crate sourceview;
extern crate tiny_keccak;
extern crate webkit2gtk;

pub mod preview;
pub mod state;
pub mod ui;

use ui::App;

fn main() {
    // Инициализировать исходное состояние пользовательского интерфейса.
    App::new()
        // "Соединить" события с пользовательским интерфейсом.
        .connect_events()
        // Показать пользовательский интерфейс и запустить программу.
        .then_execute();
}
```
Вы можете заметить отличия от приведенного в прошлой главе кода. В этой главе
мы будем использовать паттерн **Builder** для подготовки к работе и исполнению
нашей программы. Данный паттерн здесь очень кстати, так как во время
компиляции может предотвратить появление ошибок связанных с API.

Метод `App::new()` создает новый **App**, который мы передадим в метод
`connect_events()`. Данный метод преобразует **App** в **ConnectedApp**, 
который реализует `then_execute()`, показывающий пользовательский интерфейс и
выполняющий главный цикл событий. 